import os
import sys

# 添加项目根目录到Python路径，方便导入
project_root = os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
sys.path.append(project_root)

# 设置本地模型路径
os.environ['HF_HOME'] = ''
os.environ['HUGGINGFACE_HUB_CACHE'] = ''
os.environ['TRANSFORMERS_CACHE'] = ''


import torch
import cv2
import numpy as np
from datetime import datetime
from PIL import Image, ImageDraw
import matplotlib.pyplot as plt
from diffusers import StableDiffusionControlNetPipeline, ControlNetModel
from pathlib import Path
from transformers import BlipProcessor, BlipForConditionalGeneration

class DoodleToArtConverter:
    def __init__(self):
        """
        初始化涂鸦转艺术模型，使用本地模型文件
        """
        # 获取当前文件所在目录
        current_file = Path(__file__).resolve()

        # 计算模型路径（项目根目录的models文件夹）
        models_dir = current_file.parent.parent.parent / "models"

        # 设置各个模型的具体路径
        sd_model_path = models_dir / "stable-diffusion-v1-5"
        controlnet_path = models_dir / "sd-controlnet-scribble"
        blip_model_path = models_dir / "blip-image-captioning-base"

        self.device = "cuda" if torch.cuda.is_available() else "cpu"
        print(f"使用设备: {self.device}")
        print(f"项目根目录: {current_file.parent.parent.parent}")
        print(f"模型目录: {models_dir}")

        # 检查模型是否存在
        self._check_models_exist(sd_model_path, controlnet_path, blip_model_path)

        print("加载图像理解模型...")
        # 从本地加载BLIP模型
        self.caption_processor = BlipProcessor.from_pretrained(
            str(blip_model_path),
            use_fast=True,
            local_files_only=True
        )
        self.caption_model = BlipForConditionalGeneration.from_pretrained(
            str(blip_model_path),
            local_files_only=True
        ).to(self.device)
        print("✓ BLIP模型加载成功")

        print("加载ControlNet模型...")
        # 从本地加载ControlNet
        self.controlnet = ControlNetModel.from_pretrained(
            str(controlnet_path),
            torch_dtype=torch.float16 if self.device == "cuda" else torch.float32,
            local_files_only=True
        )
        print("✓ ControlNet模型加载成功")

        print("加载Stable Diffusion模型...")
        # 从本地加载Stable Diffusion
        self.pipe = StableDiffusionControlNetPipeline.from_pretrained(
            str(sd_model_path),
            controlnet=self.controlnet,
            torch_dtype=torch.float16 if self.device == "cuda" else torch.float32,
            safety_checker=None,
            requires_safety_checker=False,
            local_files_only=True
        )
        print("✓ Stable Diffusion模型加载成功")

        self.pipe = self.pipe.to(self.device)

        # 输出目录 - 指向 assets/auto_doodle_art
        self.output_dir = current_file.parent.parent.parent / "assets" / "auto_doodle_art"
        self.output_dir.mkdir(parents=True, exist_ok=True)

        # 启用内存优化
        if self.device == "cuda":
            self.pipe.enable_attention_slicing()
            try:
                self.pipe.enable_xformers_memory_efficient_attention()
                print("✓ 已启用xformers内存优化")
            except:
                print("⚠ xformers不可用，使用标准注意力")

        print("✓ 所有模型加载完成，准备就绪！")

    def _check_models_exist(self, sd_path, cn_path, blip_path):
        """检查模型文件是否存在"""
        paths_to_check = [
            (sd_path, "Stable Diffusion v1.5"),
            (cn_path, "ControlNet Scribble"),
            (blip_path, "BLIP Image Captioning")
        ]

        all_exist = True
        for path, name in paths_to_check:
            if path.exists():
                print(f"✓ {name} 模型存在于: {path}")

                # 列出主要文件
                model_files = list(path.rglob("*.bin")) + list(path.rglob("*.safetensors"))
                if model_files:
                    print(f"  找到模型文件: {len(model_files)} 个")
                else:
                    print(f"  ⚠ 未找到模型权重文件")
            else:
                print(f"✗ {name} 模型不存在于: {path}")
                all_exist = False

        if not all_exist:
            print("\n请按以下步骤操作:")
            print("1. 确保已下载模型到缓存目录 (E:/huggingface_cache)")
            print("2. 运行复制脚本将模型复制到项目models目录")
            print("3. 或者手动复制:")
            print(
                "   - BLIP: E:/huggingface_cache/models--Salesforce--blip-image-captioning-base/snapshots/xxx 到 models/blip-image-captioning-base/")
            print(
                "   - ControlNet: E:/huggingface_cache/models--lllyasviel--sd-controlnet-scribble/snapshots/xxx 到 models/sd-controlnet-scribble/")
            print(
                "   - Stable Diffusion: E:/huggingface_cache/models--runwayml--stable-diffusion-v1-5/snapshots/xxx 到 models/stable-diffusion-v1-5/")
            raise FileNotFoundError("模型文件不存在，请先下载并复制模型到项目目录")

    def auto_generate_from_doodle(self, doodle_image, num_creations=6,style="vibrant pop art style"):
        """
        完全自动化：从涂鸦到多种创意作品
        """
        print("开始自动化创意生成流程...")

        # 1. 分析涂鸦内容
        print("步骤1: 分析涂鸦内容...")
        prompt = self.auto_analyze_doodle(doodle_image)

        # 2. 预处理涂鸦
        print("步骤2: 预处理涂鸦...")
        control_image = self.preprocess_doodle(doodle_image)

        # 3. 生成多种创意变体
        print("步骤3: 生成创意作品...")
        creations = []

        for i in range(num_creations):
            print(f"  生成作品 {i + 1}/{num_creations}...")

            # 为每个变体使用不同的风格增强
            # style_enhanced_prompt = self.add_random_style(prompt)
            style_enhanced_prompt = self.add_style(prompt,style)

            generator = torch.Generator(device=self.device).manual_seed(i * 1000)

            image = self.pipe(
                prompt=style_enhanced_prompt,
                image=control_image,
                negative_prompt="low quality, blurry, ugly, deformed",
                guidance_scale=7.5,
                controlnet_conditioning_scale=1.0,
                generator=generator,
                num_inference_steps=20,
                width=512,
                height=512
            ).images[0]

            creations.append((image, style_enhanced_prompt))

        return creations, control_image

    def auto_analyze_doodle(self, doodle_image):
        """自动分析涂鸦内容"""
        if isinstance(doodle_image, str):
            image = Image.open(doodle_image).convert("RGB")
        else:
            image = doodle_image.convert("RGB")

        inputs = self.caption_processor(image, return_tensors="pt").to(self.device)

        with torch.no_grad():
            caption_ids = self.caption_model.generate(**inputs, max_length=30, num_beams=3)

        description = self.caption_processor.decode(caption_ids[0], skip_special_tokens=True)

        # 基础质量增强
        enhanced = f"{description}, high quality, detailed, artistic"

        return enhanced

    def add_random_style(self, base_prompt):
        """为提示词添加随机艺术风格"""
        styles = [
            "masterpiece oil painting",
            "beautiful watercolor art",
            "professional digital artwork",
            "fantasy concept art",
            "minimalist line art",
            "surreal dreamlike painting",
            "vibrant pop art style",
            "elegant ink drawing"
        ]

        import random
        style = random.choice(styles)

        return f"{base_prompt}, {style}"

    def add_style(self, prompt,style):
        return f"{prompt}, {style}"


    def preprocess_doodle(self, image_path, target_size=512):
        """预处理涂鸦"""
        if isinstance(image_path, str):
            image = Image.open(image_path)
        else:
            image = image_path

        image_np = np.array(image)

        if len(image_np.shape) == 3:
            gray = cv2.cvtColor(image_np, cv2.COLOR_RGB2GRAY)
        else:
            gray = image_np

        _, binary = cv2.threshold(gray, 127, 255, cv2.THRESH_BINARY)
        binary = cv2.resize(binary, (target_size, target_size))

        return Image.fromarray(binary)

    def save_and_display_results(self, original_doodle, creations):
        """保存和显示结果"""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")

        session_dir = self.output_dir / f"art_{timestamp}"
        session_dir.mkdir(exist_ok=True)

        # 创建展示图
        fig, axes = plt.subplots(2, (len(creations) + 1) // 2, figsize=(15, 10))
        axes = axes.flatten()

        # 显示原始涂鸦
        axes[0].imshow(original_doodle, cmap='gray')
        axes[0].set_title("Original Doodle")
        axes[0].axis('off')

        # 显示生成的作品
        for i, (img, prompt) in enumerate(creations):
            axes[i + 1].imshow(img)
            axes[i + 1].set_title(f"Creation {i + 1}")
            axes[i + 1].axis('off')

            # 保存单个作品

            creation_path = session_dir / f"{timestamp}_creation_{i + 1}.png"
            img.save(creation_path)

        # 保存原始涂鸦
        original_path = session_dir / f"{timestamp}_original.png"
        original_doodle.save(original_path)

        # 保存提示词信息
        prompts_path = session_dir / f"{timestamp}_prompts.txt"
        with open(prompts_path, "w") as f:
            for i, (_, prompt) in enumerate(creations):
                f.write(f"Creation {i + 1}: {prompt}\n")

        plt.tight_layout()
        plt.show()

        print(f"所有作品已保存到: {self.output_dir}")
        print(f"时间戳: {timestamp}")


def main():
    converter=DoodleToArtConverter()
    doodle_img=Image.open("E:/GesturePaint/assets/saved_drawings/drawing_1763901950.png")
    creations,processed_doodle=converter.auto_generate_from_doodle(doodle_img,num_creations=1,style="vibrant pop art style")

    converter.save_and_display_results(processed_doodle, creations)

if __name__ == "__main__":
    main()

